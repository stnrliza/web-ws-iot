{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { i as isFirestoreDataReference, a as isFirestoreQuery, b as isDatabaseReference, c as isStorageReference, n as noop, u as useFirebaseApp, d as isObject, e as checkWrittenTarget, f as useIsSSR, g as isPOJO, h as isDocumentRef, w as walkGet, j as callOnceWithArg, k as isCollectionRef, l as walkSet, m as getGlobalScope, o as authUserMap, s as setupOnAuthStateChanged, p as isClient, _ as _FirebaseAppInjectionKey } from './shared/vuefire.9aba3ce1.mjs';\nexport { V as VueFireAppCheck, t as getCurrentUser, v as updateCurrentUserProfile, y as useAppCheck, x as useAppCheckToken, q as useCurrentUser, r as useIsCurrentUserLoaded } from './shared/vuefire.9aba3ce1.mjs';\nimport { unref, ref, shallowRef, getCurrentScope, isRef, watch, onScopeDispose, getCurrentInstance, onServerPrefetch, isVue3, toRef, effectScope, computed } from 'vue-demi';\nimport { get, onValue, onChildAdded, onChildRemoved, onChildChanged, onChildMoved, getDatabase } from 'firebase/database';\nimport { Timestamp, GeoPoint, getDocs, onSnapshot, getDoc, getFirestore } from 'firebase/firestore';\nimport { getAuth } from 'firebase/auth';\nimport { getStorage, getDownloadURL, getMetadata, updateMetadata, uploadBytesResumable } from 'firebase/storage';\nimport 'firebase/app-check';\nimport 'firebase/app';\nconst _initialStatesMap = /* @__PURE__ */new WeakMap();\nfunction useSSRInitialState(initialState, firebaseApp) {\n  if (!_initialStatesMap.has(firebaseApp)) {\n    _initialStatesMap.set(firebaseApp, initialState || {\n      f: {},\n      r: {},\n      s: {},\n      u: {}\n    });\n  }\n  return _initialStatesMap.get(firebaseApp);\n}\nfunction getInitialValue(dataSource, ssrKey, fallbackValue, firebaseApp) {\n  if (!dataSource) return fallbackValue;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType) return fallbackValue;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType] || {};\n  const key = ssrKey || path;\n  return key && key in initialState ? initialState[key] : fallbackValue;\n}\nfunction deferInitialValueSetup(dataSource, ssrKey, promise, firebaseApp) {\n  if (!dataSource) return;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType) return;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType];\n  const key = ssrKey || path;\n  if (key) {\n    promise.then(value => {\n      initialState[key] = value;\n    }).catch(noop);\n    return key;\n  }\n}\nfunction getDataSourceInfo(dataSource) {\n  return isFirestoreDataReference(dataSource) || isFirestoreQuery(dataSource) ? [\"f\", dataSource.path] : isDatabaseReference(dataSource) ? [\"r\", dataSource.toString()] : isStorageReference(dataSource) ? [\"s\", dataSource.toString()] : [];\n}\nconst appPendingPromises = /* @__PURE__ */new WeakMap();\nfunction addPendingPromise(promise, dataSource, ssrKey) {\n  const app = useFirebaseApp();\n  if (!appPendingPromises.has(app)) {\n    appPendingPromises.set(app, /* @__PURE__ */new Map());\n  }\n  const pendingPromises = appPendingPromises.get(app);\n  const key = deferInitialValueSetup(dataSource, ssrKey, promise, app);\n  if (key) {\n    pendingPromises.set(key, promise);\n  } else {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.warn(\"[VueFire SSR]: Could not get the path of the data source\");\n    }\n  }\n  return key ? () => pendingPromises.delete(key) : noop;\n}\nfunction usePendingPromises(app) {\n  app = app || useFirebaseApp();\n  const pendingPromises = appPendingPromises.get(app);\n  const p = pendingPromises ? Promise.all(Array.from(pendingPromises).map(([key, promise]) => promise.then(data => [key, data]))) : Promise.resolve([]);\n  appPendingPromises.delete(app);\n  return p;\n}\nfunction createRecordFromDatabaseSnapshot(snapshot) {\n  if (!snapshot.exists()) return null;\n  const value = snapshot.val();\n  return isObject(value) ? Object.defineProperty(value, \"id\", {\n    // allow destructuring without interfering without using the `id` property\n    value: snapshot.key\n  }) : {\n    // if the value is a primitive we can just return a regular object, it's easier to debug\n    // @ts-expect-error: $value doesn't exist\n    $value: value,\n    id: snapshot.key\n  };\n}\nfunction indexForKey(array, key) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i].id === key) return i;\n  }\n  return -1;\n}\nconst DEFAULT_OPTIONS$1 = {\n  reset: false,\n  serialize: createRecordFromDatabaseSnapshot,\n  wait: true\n};\nfunction bindAsObject(target, document, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let unsubscribe = noop;\n  function onValueCallback(snapshot) {\n    const value = options.serialize(snapshot);\n    target.value = value;\n    resolve(value);\n  }\n  if (options.once) {\n    get(document).then(onValueCallback).catch(reject);\n  } else {\n    unsubscribe = onValue(document, onValueCallback, reject);\n  }\n  return reset => {\n    unsubscribe();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      target.value = value;\n    }\n  };\n}\nfunction bindAsArray(target, collection, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let arrayRef = options.wait ? [] : target;\n  if (!options.wait) {\n    target.value = [];\n  }\n  let removeChildAddedListener = noop;\n  let removeChildChangedListener = noop;\n  let removeChildRemovedListener = noop;\n  let removeChildMovedListener = noop;\n  let removeValueListener = noop;\n  if (options.once) {\n    get(collection).then(data => {\n      const array = [];\n      data.forEach(snapshot => {\n        array.push(options.serialize(snapshot));\n      });\n      resolve(target.value = array);\n    }).catch(reject);\n  } else {\n    removeChildAddedListener = onChildAdded(collection, (snapshot, prevKey) => {\n      const array = unref(arrayRef);\n      const index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n      array.splice(index, 0, options.serialize(snapshot));\n    }, reject);\n    removeChildRemovedListener = onChildRemoved(collection, snapshot => {\n      const array = unref(arrayRef);\n      array.splice(indexForKey(array, snapshot.key), 1);\n    }, reject);\n    removeChildChangedListener = onChildChanged(collection, snapshot => {\n      const array = unref(arrayRef);\n      array.splice(indexForKey(array, snapshot.key), 1,\n      // cannot be null because it exists\n      options.serialize(snapshot));\n    }, reject);\n    removeChildMovedListener = onChildMoved(collection, (snapshot, prevKey) => {\n      const array = unref(arrayRef);\n      const index = indexForKey(array, snapshot.key);\n      const oldRecord = array.splice(index, 1)[0];\n      const newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n      array.splice(newIndex, 0, oldRecord);\n    }, reject);\n    removeValueListener = onValue(collection, () => {\n      const array = unref(arrayRef);\n      if (options.wait) {\n        target.value = array;\n        arrayRef = target;\n      }\n      resolve(array);\n      removeValueListener();\n    }, reject);\n  }\n  return reset => {\n    removeValueListener();\n    removeChildAddedListener();\n    removeChildRemovedListener();\n    removeChildChangedListener();\n    removeChildMovedListener();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      target.value = value;\n    }\n  };\n}\nfunction _useDatabaseRef(reference, localOptions = {}, isList = false) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, localOptions);\n  const initialSourceValue = unref(reference);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDatabaseObject()/useDatabaseList()\")) {\n      return data;\n    }\n  }\n  const isSSR = useIsSSR();\n  if (isSSR) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(initialSourceValue, options.ssrKey, data.value, useFirebaseApp());\n  data.value = initialValue;\n  const hasInitialValue = isList ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const error = ref();\n  const pending = ref(false);\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindDatabaseRef() {\n    const referenceValue = unref(reference);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!referenceValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (Array.isArray(data.value)) {\n        unbind = bindAsArray(data, referenceValue, resolve, reject, options);\n      } else {\n        unbind = bindAsObject(data, referenceValue, resolve, reject, options);\n      }\n    }).catch(reason => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      throw reason;\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(reference)) {\n    stopWatcher = watch(reference, bindDatabaseRef);\n  }\n  bindDatabaseRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise.value);\n    }\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    // allow destructuring without interfering with the ref itself\n    data: {\n      get: () => data\n    },\n    error: {\n      get: () => error\n    },\n    pending: {\n      get: () => pending\n    },\n    promise: {\n      get: () => promise\n    },\n    stop: {\n      get: () => stop\n    }\n  });\n}\nfunction useDatabaseList(reference, options) {\n  const data = ref([]);\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  }, true);\n}\nconst useList = useDatabaseList;\nfunction useDatabaseObject(reference, options) {\n  const data = ref();\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  });\n}\nconst useObject = useDatabaseObject;\nfunction useDatabase(name) {\n  return getDatabase(useFirebaseApp(name));\n}\nconst firestoreDefaultConverter = {\n  toFirestore(data) {\n    return data;\n  },\n  fromFirestore(snapshot, options) {\n    return snapshot.exists() ? Object.defineProperties(snapshot.data(options), {\n      id: {\n        value: snapshot.id\n      }\n      // TODO: check if worth adding or should be through an option\n      // It could also be an example in the docs about converters\n      // $meta: {\n      //   value: snapshot.metadata,\n      // },\n      // $ref: { get: () => snapshot.ref },\n    }) : null;\n  }\n};\nfunction extractRefs(doc, oldDoc, subs, options) {\n  if (!isPOJO(doc)) return [doc, {}];\n  const dataAndRefs = [{}, {}];\n  const subsByPath = Object.keys(subs).reduce((resultSubs, subKey) => {\n    const sub = subs[subKey];\n    resultSubs[sub.path] = sub.data();\n    return resultSubs;\n  }, {});\n  function recursiveExtract(doc2, oldDoc2, path, result) {\n    oldDoc2 = oldDoc2 || {};\n    const [data, refs] = result;\n    Object.getOwnPropertyNames(doc2).forEach(propertyName => {\n      const descriptor = Object.getOwnPropertyDescriptor(doc2, propertyName);\n      if (descriptor && !descriptor.enumerable) {\n        Object.defineProperty(data, propertyName, descriptor);\n      }\n    });\n    for (const key in doc2) {\n      const ref = doc2[key];\n      if (\n      // primitives\n      ref == null ||\n      // TODO: check and remove\n      // Firestore < 4.13\n      ref instanceof Date || ref instanceof Timestamp || ref instanceof GeoPoint) {\n        data[key] = ref;\n      } else if (isDocumentRef(ref)) {\n        const refSubKey = path + key;\n        data[key] =\n        // if the ref was already bound, keep the same object\n        // otherwise set the path as a string so it can be bound later\n        // https://github.com/vuejs/vuefire/issues/831\n        // https://github.com/vuejs/vuefire/pull/1223\n        refSubKey in subs ? oldDoc2[key] : ref.path;\n        refs[refSubKey] = ref.converter ? ref : ref.withConverter(options.converter);\n      } else if (Array.isArray(ref)) {\n        data[key] = Array(ref.length);\n        for (let i = 0; i < ref.length; i++) {\n          const newRef = ref[i];\n          if (newRef && newRef.path in subsByPath) data[key][i] = subsByPath[newRef.path];\n        }\n        recursiveExtract(ref, oldDoc2[key] || data[key], path + key + \".\", [data[key], refs]);\n      } else if (isObject(ref)) {\n        data[key] = {};\n        recursiveExtract(ref, oldDoc2[key], path + key + \".\", [data[key], refs]);\n      } else {\n        data[key] = ref;\n      }\n    }\n  }\n  recursiveExtract(doc, oldDoc, \"\", dataAndRefs);\n  return dataAndRefs;\n}\nconst DEFAULT_OPTIONS = {\n  reset: false,\n  wait: true,\n  maxRefDepth: 2,\n  converter: firestoreDefaultConverter,\n  snapshotOptions: {\n    serverTimestamps: \"estimate\"\n  }\n};\nfunction unsubscribeAll(subs) {\n  for (const sub in subs) {\n    subs[sub].unsub();\n  }\n}\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject) {\n  const [data, refs] = extractRefs(\n  // Pass snapshot options\n  // @ts-expect-error: FIXME: use better types\n  snapshot.data(options.snapshotOptions), walkGet(target, path), subs, options);\n  ops.set(target, path, data);\n  subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject);\n}\nfunction subscribeToDocument({\n  ref: ref2,\n  target,\n  path,\n  depth,\n  resolve,\n  reject,\n  ops\n}, options) {\n  const subs = /* @__PURE__ */Object.create(null);\n  let unbind = noop;\n  if (options.once) {\n    getDoc(ref2).then(snapshot => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject);\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }).catch(reject);\n  } else {\n    unbind = onSnapshot(ref2, snapshot => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject);\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }, reject);\n  }\n  return () => {\n    unbind();\n    unsubscribeAll(subs);\n  };\n}\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject) {\n  const refKeys = Object.keys(refs);\n  const missingKeys = Object.keys(subs).filter(refKey => refKeys.indexOf(refKey) < 0);\n  missingKeys.forEach(refKey => {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth) return resolve(path);\n  let resolvedCount = 0;\n  const totalToResolve = refKeys.length;\n  const validResolves = /* @__PURE__ */Object.create(null);\n  function deepResolve(key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve) resolve(path);\n    }\n  }\n  refKeys.forEach(refKey => {\n    const sub = subs[refKey];\n    const ref2 = refs[refKey];\n    const docPath = `${path}.${refKey}`;\n    validResolves[docPath] = true;\n    if (sub) {\n      if (sub.path !== ref2.path) sub.unsub();else return;\n    }\n    subs[refKey] = {\n      data: () => walkGet(target, docPath),\n      unsub: subscribeToDocument({\n        ref: ref2,\n        target,\n        path: docPath,\n        depth,\n        ops,\n        resolve: deepResolve.bind(null, docPath),\n        reject\n      }, options),\n      path: ref2.path\n    };\n  });\n}\nfunction bindCollection(target, collection, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const {\n    snapshotListenOptions,\n    snapshotOptions,\n    wait,\n    once\n  } = options;\n  const key = \"value\";\n  let arrayRef = ref(wait ? [] : target.value);\n  if (!wait) ops.set(target, key, []);\n  const originalResolve = resolve;\n  let isResolved;\n  let stopOnSnapshot = noop;\n  const arraySubs = [];\n  const change = {\n    added: ({\n      newIndex,\n      doc\n    }) => {\n      arraySubs.splice(newIndex, 0, /* @__PURE__ */Object.create(null));\n      const subs = arraySubs[newIndex];\n      const [data, refs] = extractRefs(\n      // @ts-expect-error: FIXME: wrong cast, needs better types\n      doc.data(snapshotOptions), void 0, subs, options);\n      ops.add(unref(arrayRef), newIndex, data);\n      subscribeToRefs(options, arrayRef, `${key}.${newIndex}`, subs, refs, ops, 0, resolve.bind(null, doc), reject);\n    },\n    modified: ({\n      oldIndex,\n      newIndex,\n      doc\n    }) => {\n      const array = unref(arrayRef);\n      const subs = arraySubs[oldIndex];\n      const oldData = array[oldIndex];\n      const [data, refs] = extractRefs(\n      // @ts-expect-error: FIXME: Better types\n      doc.data(snapshotOptions), oldData, subs, options);\n      arraySubs.splice(newIndex, 0, subs);\n      ops.remove(array, oldIndex);\n      ops.add(array, newIndex, data);\n      subscribeToRefs(options, arrayRef, `${key}.${newIndex}`, subs, refs, ops, 0, resolve, reject);\n    },\n    removed: ({\n      oldIndex\n    }) => {\n      const array = unref(arrayRef);\n      ops.remove(array, oldIndex);\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n  function onSnapshotCallback(snapshot) {\n    const docChanges = snapshot.docChanges(snapshotListenOptions);\n    if (!isResolved && docChanges.length) {\n      isResolved = true;\n      let count = 0;\n      const expectedItems = docChanges.length;\n      const validDocs = /* @__PURE__ */Object.create(null);\n      for (let i = 0; i < expectedItems; i++) {\n        validDocs[docChanges[i].doc.id] = true;\n      }\n      resolve = data => {\n        if (data && data.id in validDocs) {\n          if (++count >= expectedItems) {\n            if (wait) {\n              ops.set(target, key, unref(arrayRef));\n              arrayRef = target;\n            }\n            originalResolve(unref(arrayRef));\n            resolve = noop;\n          }\n        }\n      };\n    }\n    docChanges.forEach(c => {\n      change[c.type](c);\n    });\n    if (!docChanges.length) {\n      if (wait) {\n        ops.set(target, key, unref(arrayRef));\n        arrayRef = target;\n      }\n      resolve(unref(arrayRef));\n    }\n  }\n  if (once) {\n    getDocs(collection).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(collection, onSnapshotCallback, reject);\n  }\n  return reset => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      ops.set(target, key, value);\n    }\n    arraySubs.forEach(unsubscribeAll);\n  };\n}\nfunction bindDocument(target, document, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const key = \"value\";\n  const subs = /* @__PURE__ */Object.create(null);\n  resolve = callOnceWithArg(resolve, () => walkGet(target, key));\n  let stopOnSnapshot = noop;\n  function onSnapshotCallback(snapshot) {\n    if (snapshot.exists()) {\n      updateDataFromDocumentSnapshot(options, target, key, snapshot, subs, ops, 0, resolve, reject);\n    } else {\n      ops.set(target, key, null);\n      resolve(null);\n    }\n  }\n  if (options.once) {\n    getDoc(document).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(document, onSnapshotCallback, reject);\n  }\n  return reset => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      ops.set(target, key, value);\n    }\n    unsubscribeAll(subs);\n  };\n}\nfunction _useFirestoreRef(docOrCollectionRef, localOptions) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS, localOptions);\n  const initialSourceValue = unref(docOrCollectionRef);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDocument()/useCollection()\")) {\n      return data;\n    }\n  }\n  if (useIsSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(initialSourceValue, options.ssrKey, data.value, useFirebaseApp());\n  data.value = initialValue;\n  const hasInitialValue =\n  // TODO: we need a stricter check for collections and queries and the initial target is passed as a ref([]) but\n  // maybe that [] should be set here instead. It's also worth taking into account that a custom ref can be passed as\n  // target as it should probably be initially empty but maybe this is too much to ask.\n  // TODO: add and test || isFirestoreQuery()\n  isCollectionRef(initialSourceValue) ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const pending = ref(false);\n  const error = ref();\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindFirestoreRef() {\n    let docRefValue = unref(docOrCollectionRef);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!docRefValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (!docRefValue.converter) {\n        docRefValue = docRefValue.withConverter(\n        // @ts-expect-error: seems like a ts error\n        options.converter);\n      }\n      unbind = (isDocumentRef(docRefValue) ? bindDocument : bindCollection)(\n      // @ts-expect-error: cannot type with the ternary\n      data, docRefValue, ops, resolve, reject, options);\n    }).catch(reason => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      return Promise.reject(reason);\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(docOrCollectionRef)) {\n    stopWatcher = watch(docOrCollectionRef, bindFirestoreRef);\n  }\n  bindFirestoreRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue, options.ssrKey);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    error: {\n      get: () => error\n    },\n    data: {\n      get: () => data\n    },\n    pending: {\n      get: () => pending\n    },\n    promise: {\n      get: () => promise\n    },\n    stop: {\n      get: () => stop\n    }\n  });\n}\nconst ops = {\n  set: (target, key, value) => walkSet(target, key, value),\n  add: (array, index, data) => array.splice(index, 0, data),\n  remove: (array, index) => array.splice(index, 1)\n};\nfunction useCollection(collectionRef, options) {\n  return _useFirestoreRef(collectionRef, {\n    target: ref([]),\n    ...options\n  });\n}\nfunction useDocument(documentRef, options) {\n  return _useFirestoreRef(documentRef, options);\n}\nfunction useFirestore(name) {\n  return getFirestore(useFirebaseApp(name));\n}\nconst databaseUnbinds = /* @__PURE__ */new WeakMap();\nfunction internalUnbind$1(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\nconst databasePluginDefaults = {\n  bindName: \"$databaseBind\",\n  unbindName: \"$databaseUnbind\"\n};\nfunction databasePlugin(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, databasePluginDefaults, pluginOptions);\n  const {\n    bindName,\n    unbindName\n  } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function databaseUnbind(key, reset) {\n    internalUnbind$1(key, databaseUnbinds.get(this), reset);\n    delete this.$firebaseRefs[key];\n  };\n  GlobalTarget[bindName] = function databaseBind(key, source, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!databaseUnbinds.has(this)) {\n      databaseUnbinds.set(this, {});\n    }\n    const unbinds = databaseUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    if (pluginOptions) {\n      if (!pluginOptions.bindName) {\n        GlobalTarget[\"$rtdbBind\"] = GlobalTarget[bindName];\n      }\n      if (!pluginOptions.unbindName) {\n        GlobalTarget[\"$rtdbUnbind\"] = GlobalTarget[unbindName];\n      }\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(() => effectScope());\n    const {\n      promise,\n      stop: _unbind\n    } = scope.run(() => _useDatabaseRef(source, {\n      target,\n      ...options\n    }));\n    const unbind = reset => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firebaseRefs[key] = source.ref;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firebaseRefs = /* @__PURE__ */Object.create(null);\n    },\n    created() {\n      let bindings = this.$options.firebase;\n      if (typeof bindings === \"function\") {\n        bindings = bindings.call(this);\n      }\n      if (!bindings) return;\n      for (const key in bindings) {\n        this[bindName](\n        // ts\n        key, bindings[key], globalOptions);\n      }\n    },\n    beforeUnmount() {\n      const unbinds = databaseUnbinds.get(this);\n      if (unbinds) {\n        for (const key in unbinds) {\n          unbinds[key]();\n        }\n      }\n      this.$firebaseRefs = null;\n    }\n  });\n}\nfunction VueFireDatabaseOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return databasePlugin(app, pluginOptions, firebaseApp);\n  };\n}\nconst firestoreUnbinds = /* @__PURE__ */new WeakMap();\nfunction internalUnbind(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\nconst firestorePluginDefaults = {\n  bindName: \"$firestoreBind\",\n  unbindName: \"$firestoreUnbind\"\n};\nconst firestorePlugin = function firestorePlugin2(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, firestorePluginDefaults, pluginOptions);\n  const {\n    bindName,\n    unbindName\n  } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function firestoreUnbind(key, reset) {\n    internalUnbind(key, firestoreUnbinds.get(this), reset);\n    delete this.$firestoreRefs[key];\n  };\n  GlobalTarget[bindName] = function firestoreBind(key, docOrCollectionRef, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!firestoreUnbinds.has(this)) {\n      firestoreUnbinds.set(this, {});\n    }\n    const unbinds = firestoreUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(() => effectScope());\n    const {\n      promise,\n      stop: _unbind\n    } = scope.run(() => _useFirestoreRef(docOrCollectionRef, {\n      target,\n      ...options\n    }));\n    const unbind = reset => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firestoreRefs[key] =\n    // ts\n    docOrCollectionRef;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firestoreRefs = /* @__PURE__ */Object.create(null);\n    },\n    created() {\n      const {\n        firestore\n      } = this.$options;\n      const refs = typeof firestore === \"function\" ? firestore.call(this) : firestore;\n      if (!refs) return;\n      for (const key in refs) {\n        this[bindName](key,\n        // @ts-expect-error: FIXME: there is probably a wrong type in global properties\n        refs[key], globalOptions);\n      }\n    },\n    beforeUnmount() {\n      const unbinds = firestoreUnbinds.get(this);\n      if (unbinds) {\n        for (const subKey in unbinds) {\n          unbinds[subKey]();\n        }\n      }\n      this.$firestoreRefs = null;\n    }\n  });\n};\nfunction VueFireFirestoreOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return firestorePlugin(app, pluginOptions, firebaseApp);\n  };\n}\nfunction VueFireAuth(initialUser) {\n  return (firebaseApp, app) => {\n    const user = getGlobalScope(firebaseApp, app).run(() => ref(initialUser));\n    authUserMap.set(firebaseApp, user);\n    setupOnAuthStateChanged(user, firebaseApp);\n  };\n}\nfunction useFirebaseAuth(name) {\n  return isClient ? getAuth(useFirebaseApp(name)) : null;\n}\nfunction useFirebaseStorage(name) {\n  return getStorage(useFirebaseApp(name));\n}\nfunction useStorageFileUrl(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const url = ref();\n  url.value = getInitialValue(initialSourceValue, void 0, url.value, useFirebaseApp());\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getDownloadURL(storageSource).then(downloadUrl => url.value = downloadUrl).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(url.value = null);\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return {\n    url,\n    refresh,\n    promise\n  };\n}\nfunction useStorageFileMetadata(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const metadata = shallowRef();\n  if (initialSourceValue) {\n    metadata.value = getInitialValue(initialSourceValue,\n    // 'm ' is a prefix to differentiate from urls since both are stored in the same object\n    \"m \" + initialSourceValue.toString(), metadata.value, useFirebaseApp());\n  }\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getMetadata(storageSource).then(data => metadata.value = data).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(metadata.value = null);\n    }\n    return promise.value;\n  }\n  function update(newMetadata) {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = updateMetadata(storageSource, newMetadata).then(newData => {\n        return metadata.value = newData;\n      });\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[VueFire]: \"update()\" called with no storage source.');\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return {\n    metadata,\n    update,\n    refresh,\n    promise\n  };\n}\nfunction useStorageFile(storageRef) {\n  const {\n    url,\n    refresh: refreshUrl\n  } = useStorageFileUrl(storageRef);\n  const {\n    metadata,\n    update: updateMetadata2,\n    refresh: refreshMetadata\n  } = useStorageFileMetadata(storageRef);\n  const uploadTask = shallowRef();\n  const snapshot = shallowRef();\n  const uploadError = shallowRef();\n  const uploadProgress = computed(() => {\n    const snap = unref(snapshot);\n    return snap ? snap.bytesTransferred / snap.totalBytes : null;\n  });\n  let unsub = noop;\n  function upload(newData, newMetadata) {\n    const storageSource = unref(storageRef);\n    const currentTask = unref(uploadTask);\n    if (currentTask) {\n      currentTask.cancel();\n    }\n    uploadError.value = null;\n    snapshot.value = null;\n    uploadTask.value = null;\n    url.value = null;\n    metadata.value = null;\n    unsub();\n    if (storageSource) {\n      const newTask = uploadBytesResumable(storageSource, newData, newMetadata);\n      uploadTask.value = newTask;\n      snapshot.value = newTask.snapshot;\n      unsub = newTask.on(\"state_changed\", newSnapshot => {\n        snapshot.value = newSnapshot;\n      });\n      return newTask.then(finalSnapshot => {\n        metadata.value = finalSnapshot.metadata;\n        refreshUrl();\n      }).catch(err => {\n        uploadError.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        unsub();\n        uploadTask.value = null;\n      });\n    }\n  }\n  function refresh() {\n    return Promise.all([refreshUrl(), refreshMetadata()]);\n  }\n  if (isRef(storageRef)) {\n    watch(storageRef, storageSource => {\n      if (!storageSource) {\n        if (uploadTask.value) {\n          unsub();\n          uploadTask.value.cancel();\n        }\n        uploadTask.value = null;\n        snapshot.value = null;\n      }\n      refresh();\n    });\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(unsub);\n  }\n  return {\n    url,\n    metadata,\n    snapshot,\n    uploadTask,\n    uploadError,\n    uploadProgress,\n    upload,\n    updateMetadata: updateMetadata2,\n    refresh\n    // promise,\n  };\n}\n\nconst useStorage = useFirebaseStorage;\nconst useStorageUrl = useStorageFileUrl;\nconst useStorageMetadata = useStorageFileMetadata;\nconst useStorageObject = useStorageFile;\nfunction VueFire(app, {\n  firebaseApp,\n  modules = []\n}) {\n  app.provide(_FirebaseAppInjectionKey, firebaseApp);\n  for (const firebaseModule of modules) {\n    firebaseModule(firebaseApp, app);\n  }\n}\nexport { VueFire, VueFireAuth, VueFireDatabaseOptionsAPI, VueFireFirestoreOptionsAPI, databasePlugin, firestoreDefaultConverter, firestorePlugin, DEFAULT_OPTIONS$1 as globalDatabaseOptions, DEFAULT_OPTIONS as globalFirestoreOptions, databasePlugin as rtdbPlugin, useCollection, useDatabase, useDatabaseList, useDatabaseObject, useDocument, useFirebaseApp, useFirebaseAuth, useFirebaseStorage, useFirestore, useList, useObject, usePendingPromises, useSSRInitialState, useStorage, useStorageFile, useStorageFileMetadata, useStorageFileUrl, useStorageMetadata, useStorageObject, useStorageUrl };","map":{"version":3,"names":["i","isFirestoreDataReference","a","isFirestoreQuery","b","isDatabaseReference","c","isStorageReference","n","noop","u","useFirebaseApp","d","isObject","e","checkWrittenTarget","f","useIsSSR","g","isPOJO","h","isDocumentRef","w","walkGet","j","callOnceWithArg","k","isCollectionRef","l","walkSet","m","getGlobalScope","o","authUserMap","s","setupOnAuthStateChanged","p","isClient","_","_FirebaseAppInjectionKey","V","VueFireAppCheck","t","getCurrentUser","v","updateCurrentUserProfile","y","useAppCheck","x","useAppCheckToken","q","useCurrentUser","r","useIsCurrentUserLoaded","unref","ref","shallowRef","getCurrentScope","isRef","watch","onScopeDispose","getCurrentInstance","onServerPrefetch","isVue3","toRef","effectScope","computed","get","onValue","onChildAdded","onChildRemoved","onChildChanged","onChildMoved","getDatabase","Timestamp","GeoPoint","getDocs","onSnapshot","getDoc","getFirestore","getAuth","getStorage","getDownloadURL","getMetadata","updateMetadata","uploadBytesResumable","_initialStatesMap","WeakMap","useSSRInitialState","initialState","firebaseApp","has","set","getInitialValue","dataSource","ssrKey","fallbackValue","sourceType","path","getDataSourceInfo","key","deferInitialValueSetup","promise","then","value","catch","toString","appPendingPromises","addPendingPromise","app","Map","pendingPromises","process","env","NODE_ENV","console","warn","delete","usePendingPromises","Promise","all","Array","from","map","data","resolve","createRecordFromDatabaseSnapshot","snapshot","exists","val","Object","defineProperty","$value","id","indexForKey","array","length","DEFAULT_OPTIONS$1","reset","serialize","wait","bindAsObject","target","document","reject","extraOptions","options","assign","unsubscribe","onValueCallback","once","bindAsArray","collection","arrayRef","removeChildAddedListener","removeChildChangedListener","removeChildRemovedListener","removeChildMovedListener","removeValueListener","forEach","push","prevKey","index","splice","oldRecord","newIndex","_useDatabaseRef","reference","localOptions","isList","unbind","initialSourceValue","isSSR","initialValue","hasInitialValue","shouldStartAsPending","error","pending","hasCurrentScope","removePendingPromise","bindDatabaseRef","referenceValue","newPromise","isArray","reason","finally","stopWatcher","stop","defineProperties","useDatabaseList","useList","useDatabaseObject","useObject","useDatabase","name","firestoreDefaultConverter","toFirestore","fromFirestore","extractRefs","doc","oldDoc","subs","dataAndRefs","subsByPath","keys","reduce","resultSubs","subKey","sub","recursiveExtract","doc2","oldDoc2","result","refs","getOwnPropertyNames","propertyName","descriptor","getOwnPropertyDescriptor","enumerable","Date","refSubKey","converter","withConverter","newRef","DEFAULT_OPTIONS","maxRefDepth","snapshotOptions","serverTimestamps","unsubscribeAll","unsub","updateDataFromDocumentSnapshot","ops","depth","subscribeToRefs","subscribeToDocument","ref2","create","refKeys","missingKeys","filter","refKey","indexOf","resolvedCount","totalToResolve","validResolves","deepResolve","docPath","bind","bindCollection","snapshotListenOptions","originalResolve","isResolved","stopOnSnapshot","arraySubs","change","added","add","modified","oldIndex","oldData","remove","removed","onSnapshotCallback","docChanges","count","expectedItems","validDocs","type","bindDocument","_useFirestoreRef","docOrCollectionRef","bindFirestoreRef","docRefValue","useCollection","collectionRef","useDocument","documentRef","useFirestore","databaseUnbinds","internalUnbind$1","unbinds","databasePluginDefaults","bindName","unbindName","databasePlugin","pluginOptions","globalOptions","GlobalTarget","config","globalProperties","prototype","databaseUnbind","$firebaseRefs","databaseBind","source","userOptions","$data","scope","run","_unbind","mixin","beforeCreate","created","bindings","$options","firebase","call","beforeUnmount","VueFireDatabaseOptionsAPI","firestoreUnbinds","internalUnbind","firestorePluginDefaults","firestorePlugin","firestorePlugin2","firestoreUnbind","$firestoreRefs","firestoreBind","firestore","VueFireFirestoreOptionsAPI","VueFireAuth","initialUser","user","useFirebaseAuth","useFirebaseStorage","useStorageFileUrl","storageRef","url","refresh","storageSource","downloadUrl","useStorageFileMetadata","metadata","update","newMetadata","newData","useStorageFile","refreshUrl","updateMetadata2","refreshMetadata","uploadTask","uploadError","uploadProgress","snap","bytesTransferred","totalBytes","upload","currentTask","cancel","newTask","on","newSnapshot","finalSnapshot","err","useStorage","useStorageUrl","useStorageMetadata","useStorageObject","VueFire","modules","provide","firebaseModule","globalDatabaseOptions","globalFirestoreOptions","rtdbPlugin"],"sources":["D:/rafi/koding/vue3/IOTUB1/node_modules/vuefire/dist/index.mjs"],"sourcesContent":["import { i as isFirestoreDataReference, a as isFirestoreQuery, b as isDatabaseReference, c as isStorageReference, n as noop, u as useFirebaseApp, d as isObject, e as checkWrittenTarget, f as useIsSSR, g as isPOJO, h as isDocumentRef, w as walkGet, j as callOnceWithArg, k as isCollectionRef, l as walkSet, m as getGlobalScope, o as authUserMap, s as setupOnAuthStateChanged, p as isClient, _ as _FirebaseAppInjectionKey } from './shared/vuefire.9aba3ce1.mjs';\nexport { V as VueFireAppCheck, t as getCurrentUser, v as updateCurrentUserProfile, y as useAppCheck, x as useAppCheckToken, q as useCurrentUser, r as useIsCurrentUserLoaded } from './shared/vuefire.9aba3ce1.mjs';\nimport { unref, ref, shallowRef, getCurrentScope, isRef, watch, onScopeDispose, getCurrentInstance, onServerPrefetch, isVue3, toRef, effectScope, computed } from 'vue-demi';\nimport { get, onValue, onChildAdded, onChildRemoved, onChildChanged, onChildMoved, getDatabase } from 'firebase/database';\nimport { Timestamp, GeoPoint, getDocs, onSnapshot, getDoc, getFirestore } from 'firebase/firestore';\nimport { getAuth } from 'firebase/auth';\nimport { getStorage, getDownloadURL, getMetadata, updateMetadata, uploadBytesResumable } from 'firebase/storage';\nimport 'firebase/app-check';\nimport 'firebase/app';\n\nconst _initialStatesMap = /* @__PURE__ */ new WeakMap();\nfunction useSSRInitialState(initialState, firebaseApp) {\n  if (!_initialStatesMap.has(firebaseApp)) {\n    _initialStatesMap.set(\n      firebaseApp,\n      initialState || { f: {}, r: {}, s: {}, u: {} }\n    );\n  }\n  return _initialStatesMap.get(firebaseApp);\n}\nfunction getInitialValue(dataSource, ssrKey, fallbackValue, firebaseApp) {\n  if (!dataSource)\n    return fallbackValue;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType)\n    return fallbackValue;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType] || {};\n  const key = ssrKey || path;\n  return key && key in initialState ? initialState[key] : fallbackValue;\n}\nfunction deferInitialValueSetup(dataSource, ssrKey, promise, firebaseApp) {\n  if (!dataSource)\n    return;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType)\n    return;\n  const initialState = useSSRInitialState(\n    void 0,\n    firebaseApp\n  )[sourceType];\n  const key = ssrKey || path;\n  if (key) {\n    promise.then((value) => {\n      initialState[key] = value;\n    }).catch(noop);\n    return key;\n  }\n}\nfunction getDataSourceInfo(dataSource) {\n  return isFirestoreDataReference(dataSource) || isFirestoreQuery(dataSource) ? [\"f\", dataSource.path] : isDatabaseReference(dataSource) ? [\"r\", dataSource.toString()] : isStorageReference(dataSource) ? [\"s\", dataSource.toString()] : [];\n}\n\nconst appPendingPromises = /* @__PURE__ */ new WeakMap();\nfunction addPendingPromise(promise, dataSource, ssrKey) {\n  const app = useFirebaseApp();\n  if (!appPendingPromises.has(app)) {\n    appPendingPromises.set(app, /* @__PURE__ */ new Map());\n  }\n  const pendingPromises = appPendingPromises.get(app);\n  const key = deferInitialValueSetup(dataSource, ssrKey, promise, app);\n  if (key) {\n    pendingPromises.set(key, promise);\n  } else {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.warn(\"[VueFire SSR]: Could not get the path of the data source\");\n    }\n  }\n  return key ? () => pendingPromises.delete(key) : noop;\n}\nfunction usePendingPromises(app) {\n  app = app || useFirebaseApp();\n  const pendingPromises = appPendingPromises.get(app);\n  const p = pendingPromises ? Promise.all(\n    Array.from(pendingPromises).map(\n      ([key, promise]) => promise.then((data) => [key, data])\n    )\n  ) : Promise.resolve([]);\n  appPendingPromises.delete(app);\n  return p;\n}\n\nfunction createRecordFromDatabaseSnapshot(snapshot) {\n  if (!snapshot.exists())\n    return null;\n  const value = snapshot.val();\n  return isObject(value) ? Object.defineProperty(value, \"id\", {\n    // allow destructuring without interfering without using the `id` property\n    value: snapshot.key\n  }) : {\n    // if the value is a primitive we can just return a regular object, it's easier to debug\n    // @ts-expect-error: $value doesn't exist\n    $value: value,\n    id: snapshot.key\n  };\n}\nfunction indexForKey(array, key) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i].id === key)\n      return i;\n  }\n  return -1;\n}\n\nconst DEFAULT_OPTIONS$1 = {\n  reset: false,\n  serialize: createRecordFromDatabaseSnapshot,\n  wait: true\n};\nfunction bindAsObject(target, document, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let unsubscribe = noop;\n  function onValueCallback(snapshot) {\n    const value = options.serialize(snapshot);\n    target.value = value;\n    resolve(value);\n  }\n  if (options.once) {\n    get(document).then(onValueCallback).catch(reject);\n  } else {\n    unsubscribe = onValue(document, onValueCallback, reject);\n  }\n  return (reset) => {\n    unsubscribe();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      target.value = value;\n    }\n  };\n}\nfunction bindAsArray(target, collection, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let arrayRef = options.wait ? [] : target;\n  if (!options.wait) {\n    target.value = [];\n  }\n  let removeChildAddedListener = noop;\n  let removeChildChangedListener = noop;\n  let removeChildRemovedListener = noop;\n  let removeChildMovedListener = noop;\n  let removeValueListener = noop;\n  if (options.once) {\n    get(collection).then((data) => {\n      const array = [];\n      data.forEach((snapshot) => {\n        array.push(options.serialize(snapshot));\n      });\n      resolve(target.value = array);\n    }).catch(reject);\n  } else {\n    removeChildAddedListener = onChildAdded(\n      collection,\n      (snapshot, prevKey) => {\n        const array = unref(arrayRef);\n        const index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n        array.splice(index, 0, options.serialize(snapshot));\n      },\n      reject\n    );\n    removeChildRemovedListener = onChildRemoved(\n      collection,\n      (snapshot) => {\n        const array = unref(arrayRef);\n        array.splice(indexForKey(array, snapshot.key), 1);\n      },\n      reject\n    );\n    removeChildChangedListener = onChildChanged(\n      collection,\n      (snapshot) => {\n        const array = unref(arrayRef);\n        array.splice(\n          indexForKey(array, snapshot.key),\n          1,\n          // cannot be null because it exists\n          options.serialize(snapshot)\n        );\n      },\n      reject\n    );\n    removeChildMovedListener = onChildMoved(\n      collection,\n      (snapshot, prevKey) => {\n        const array = unref(arrayRef);\n        const index = indexForKey(array, snapshot.key);\n        const oldRecord = array.splice(index, 1)[0];\n        const newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n        array.splice(newIndex, 0, oldRecord);\n      },\n      reject\n    );\n    removeValueListener = onValue(\n      collection,\n      () => {\n        const array = unref(arrayRef);\n        if (options.wait) {\n          target.value = array;\n          arrayRef = target;\n        }\n        resolve(array);\n        removeValueListener();\n      },\n      reject\n    );\n  }\n  return (reset) => {\n    removeValueListener();\n    removeChildAddedListener();\n    removeChildRemovedListener();\n    removeChildChangedListener();\n    removeChildMovedListener();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      target.value = value;\n    }\n  };\n}\n\nfunction _useDatabaseRef(reference, localOptions = {}, isList = false) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, localOptions);\n  const initialSourceValue = unref(reference);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDatabaseObject()/useDatabaseList()\")) {\n      return data;\n    }\n  }\n  const isSSR = useIsSSR();\n  if (isSSR) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(\n    initialSourceValue,\n    options.ssrKey,\n    data.value,\n    useFirebaseApp()\n  );\n  data.value = initialValue;\n  const hasInitialValue = isList ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const error = ref();\n  const pending = ref(false);\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindDatabaseRef() {\n    const referenceValue = unref(reference);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!referenceValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (Array.isArray(data.value)) {\n        unbind = bindAsArray(\n          data,\n          referenceValue,\n          resolve,\n          reject,\n          options\n        );\n      } else {\n        unbind = bindAsObject(data, referenceValue, resolve, reject, options);\n      }\n    }).catch((reason) => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      throw reason;\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(reference)) {\n    stopWatcher = watch(reference, bindDatabaseRef);\n  }\n  bindDatabaseRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise.value);\n    }\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    // allow destructuring without interfering with the ref itself\n    data: { get: () => data },\n    error: { get: () => error },\n    pending: { get: () => pending },\n    promise: { get: () => promise },\n    stop: { get: () => stop }\n  });\n}\n\nfunction useDatabaseList(reference, options) {\n  const data = ref([]);\n  return _useDatabaseRef(\n    reference,\n    {\n      target: data,\n      ...options\n    },\n    true\n  );\n}\nconst useList = useDatabaseList;\nfunction useDatabaseObject(reference, options) {\n  const data = ref();\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  });\n}\nconst useObject = useDatabaseObject;\nfunction useDatabase(name) {\n  return getDatabase(useFirebaseApp(name));\n}\n\nconst firestoreDefaultConverter = {\n  toFirestore(data) {\n    return data;\n  },\n  fromFirestore(snapshot, options) {\n    return snapshot.exists() ? Object.defineProperties(snapshot.data(options), {\n      id: { value: snapshot.id }\n      // TODO: check if worth adding or should be through an option\n      // It could also be an example in the docs about converters\n      // $meta: {\n      //   value: snapshot.metadata,\n      // },\n      // $ref: { get: () => snapshot.ref },\n    }) : null;\n  }\n};\nfunction extractRefs(doc, oldDoc, subs, options) {\n  if (!isPOJO(doc))\n    return [doc, {}];\n  const dataAndRefs = [\n    {},\n    {}\n  ];\n  const subsByPath = Object.keys(subs).reduce((resultSubs, subKey) => {\n    const sub = subs[subKey];\n    resultSubs[sub.path] = sub.data();\n    return resultSubs;\n  }, {});\n  function recursiveExtract(doc2, oldDoc2, path, result) {\n    oldDoc2 = oldDoc2 || {};\n    const [data, refs] = result;\n    Object.getOwnPropertyNames(doc2).forEach((propertyName) => {\n      const descriptor = Object.getOwnPropertyDescriptor(doc2, propertyName);\n      if (descriptor && !descriptor.enumerable) {\n        Object.defineProperty(data, propertyName, descriptor);\n      }\n    });\n    for (const key in doc2) {\n      const ref = doc2[key];\n      if (\n        // primitives\n        ref == null || // TODO: check and remove\n        // Firestore < 4.13\n        ref instanceof Date || ref instanceof Timestamp || ref instanceof GeoPoint\n      ) {\n        data[key] = ref;\n      } else if (isDocumentRef(ref)) {\n        const refSubKey = path + key;\n        data[key] = // if the ref was already bound, keep the same object\n        // otherwise set the path as a string so it can be bound later\n        // https://github.com/vuejs/vuefire/issues/831\n        // https://github.com/vuejs/vuefire/pull/1223\n        refSubKey in subs ? oldDoc2[key] : ref.path;\n        refs[refSubKey] = ref.converter ? ref : ref.withConverter(\n          options.converter\n        );\n      } else if (Array.isArray(ref)) {\n        data[key] = Array(ref.length);\n        for (let i = 0; i < ref.length; i++) {\n          const newRef = ref[i];\n          if (newRef && newRef.path in subsByPath)\n            data[key][i] = subsByPath[newRef.path];\n        }\n        recursiveExtract(ref, oldDoc2[key] || data[key], path + key + \".\", [\n          data[key],\n          refs\n        ]);\n      } else if (isObject(ref)) {\n        data[key] = {};\n        recursiveExtract(ref, oldDoc2[key], path + key + \".\", [data[key], refs]);\n      } else {\n        data[key] = ref;\n      }\n    }\n  }\n  recursiveExtract(doc, oldDoc, \"\", dataAndRefs);\n  return dataAndRefs;\n}\n\nconst DEFAULT_OPTIONS = {\n  reset: false,\n  wait: true,\n  maxRefDepth: 2,\n  converter: firestoreDefaultConverter,\n  snapshotOptions: { serverTimestamps: \"estimate\" }\n};\nfunction unsubscribeAll(subs) {\n  for (const sub in subs) {\n    subs[sub].unsub();\n  }\n}\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject) {\n  const [data, refs] = extractRefs(\n    // Pass snapshot options\n    // @ts-expect-error: FIXME: use better types\n    snapshot.data(options.snapshotOptions),\n    walkGet(target, path),\n    subs,\n    options\n  );\n  ops.set(target, path, data);\n  subscribeToRefs(\n    options,\n    target,\n    path,\n    subs,\n    refs,\n    ops,\n    depth,\n    resolve,\n    reject\n  );\n}\nfunction subscribeToDocument({\n  ref: ref2,\n  target,\n  path,\n  depth,\n  resolve,\n  reject,\n  ops\n}, options) {\n  const subs = /* @__PURE__ */ Object.create(null);\n  let unbind = noop;\n  if (options.once) {\n    getDoc(ref2).then((snapshot) => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(\n          options,\n          target,\n          path,\n          snapshot,\n          subs,\n          ops,\n          depth,\n          resolve,\n          reject\n        );\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }).catch(reject);\n  } else {\n    unbind = onSnapshot(\n      ref2,\n      (snapshot) => {\n        if (snapshot.exists()) {\n          updateDataFromDocumentSnapshot(\n            options,\n            target,\n            path,\n            snapshot,\n            subs,\n            ops,\n            depth,\n            resolve,\n            reject\n          );\n        } else {\n          ops.set(target, path, null);\n          resolve();\n        }\n      },\n      reject\n    );\n  }\n  return () => {\n    unbind();\n    unsubscribeAll(subs);\n  };\n}\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject) {\n  const refKeys = Object.keys(refs);\n  const missingKeys = Object.keys(subs).filter(\n    (refKey) => refKeys.indexOf(refKey) < 0\n  );\n  missingKeys.forEach((refKey) => {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth)\n    return resolve(path);\n  let resolvedCount = 0;\n  const totalToResolve = refKeys.length;\n  const validResolves = /* @__PURE__ */ Object.create(null);\n  function deepResolve(key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve)\n        resolve(path);\n    }\n  }\n  refKeys.forEach((refKey) => {\n    const sub = subs[refKey];\n    const ref2 = refs[refKey];\n    const docPath = `${path}.${refKey}`;\n    validResolves[docPath] = true;\n    if (sub) {\n      if (sub.path !== ref2.path)\n        sub.unsub();\n      else\n        return;\n    }\n    subs[refKey] = {\n      data: () => walkGet(target, docPath),\n      unsub: subscribeToDocument(\n        {\n          ref: ref2,\n          target,\n          path: docPath,\n          depth,\n          ops,\n          resolve: deepResolve.bind(null, docPath),\n          reject\n        },\n        options\n      ),\n      path: ref2.path\n    };\n  });\n}\nfunction bindCollection(target, collection, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const { snapshotListenOptions, snapshotOptions, wait, once } = options;\n  const key = \"value\";\n  let arrayRef = ref(wait ? [] : target.value);\n  if (!wait)\n    ops.set(target, key, []);\n  const originalResolve = resolve;\n  let isResolved;\n  let stopOnSnapshot = noop;\n  const arraySubs = [];\n  const change = {\n    added: ({ newIndex, doc }) => {\n      arraySubs.splice(newIndex, 0, /* @__PURE__ */ Object.create(null));\n      const subs = arraySubs[newIndex];\n      const [data, refs] = extractRefs(\n        // @ts-expect-error: FIXME: wrong cast, needs better types\n        doc.data(snapshotOptions),\n        void 0,\n        subs,\n        options\n      );\n      ops.add(unref(arrayRef), newIndex, data);\n      subscribeToRefs(\n        options,\n        arrayRef,\n        `${key}.${newIndex}`,\n        subs,\n        refs,\n        ops,\n        0,\n        resolve.bind(null, doc),\n        reject\n      );\n    },\n    modified: ({ oldIndex, newIndex, doc }) => {\n      const array = unref(arrayRef);\n      const subs = arraySubs[oldIndex];\n      const oldData = array[oldIndex];\n      const [data, refs] = extractRefs(\n        // @ts-expect-error: FIXME: Better types\n        doc.data(snapshotOptions),\n        oldData,\n        subs,\n        options\n      );\n      arraySubs.splice(newIndex, 0, subs);\n      ops.remove(array, oldIndex);\n      ops.add(array, newIndex, data);\n      subscribeToRefs(\n        options,\n        arrayRef,\n        `${key}.${newIndex}`,\n        subs,\n        refs,\n        ops,\n        0,\n        resolve,\n        reject\n      );\n    },\n    removed: ({ oldIndex }) => {\n      const array = unref(arrayRef);\n      ops.remove(array, oldIndex);\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n  function onSnapshotCallback(snapshot) {\n    const docChanges = snapshot.docChanges(snapshotListenOptions);\n    if (!isResolved && docChanges.length) {\n      isResolved = true;\n      let count = 0;\n      const expectedItems = docChanges.length;\n      const validDocs = /* @__PURE__ */ Object.create(null);\n      for (let i = 0; i < expectedItems; i++) {\n        validDocs[docChanges[i].doc.id] = true;\n      }\n      resolve = (data) => {\n        if (data && data.id in validDocs) {\n          if (++count >= expectedItems) {\n            if (wait) {\n              ops.set(target, key, unref(arrayRef));\n              arrayRef = target;\n            }\n            originalResolve(unref(arrayRef));\n            resolve = noop;\n          }\n        }\n      };\n    }\n    docChanges.forEach((c) => {\n      change[c.type](c);\n    });\n    if (!docChanges.length) {\n      if (wait) {\n        ops.set(target, key, unref(arrayRef));\n        arrayRef = target;\n      }\n      resolve(unref(arrayRef));\n    }\n  }\n  if (once) {\n    getDocs(collection).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(collection, onSnapshotCallback, reject);\n  }\n  return (reset) => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      ops.set(target, key, value);\n    }\n    arraySubs.forEach(unsubscribeAll);\n  };\n}\nfunction bindDocument(target, document, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const key = \"value\";\n  const subs = /* @__PURE__ */ Object.create(null);\n  resolve = callOnceWithArg(resolve, () => walkGet(target, key));\n  let stopOnSnapshot = noop;\n  function onSnapshotCallback(snapshot) {\n    if (snapshot.exists()) {\n      updateDataFromDocumentSnapshot(\n        options,\n        target,\n        key,\n        snapshot,\n        subs,\n        ops,\n        0,\n        resolve,\n        reject\n      );\n    } else {\n      ops.set(target, key, null);\n      resolve(null);\n    }\n  }\n  if (options.once) {\n    getDoc(document).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(document, onSnapshotCallback, reject);\n  }\n  return (reset) => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      ops.set(target, key, value);\n    }\n    unsubscribeAll(subs);\n  };\n}\n\nfunction _useFirestoreRef(docOrCollectionRef, localOptions) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS, localOptions);\n  const initialSourceValue = unref(docOrCollectionRef);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDocument()/useCollection()\")) {\n      return data;\n    }\n  }\n  if (useIsSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(\n    initialSourceValue,\n    options.ssrKey,\n    data.value,\n    useFirebaseApp()\n  );\n  data.value = initialValue;\n  const hasInitialValue = (\n    // TODO: we need a stricter check for collections and queries and the initial target is passed as a ref([]) but\n    // maybe that [] should be set here instead. It's also worth taking into account that a custom ref can be passed as\n    // target as it should probably be initially empty but maybe this is too much to ask.\n    // TODO: add and test || isFirestoreQuery()\n    isCollectionRef(initialSourceValue) ? (initialValue || []).length > 0 : initialValue !== void 0\n  );\n  let shouldStartAsPending = !hasInitialValue;\n  const pending = ref(false);\n  const error = ref();\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindFirestoreRef() {\n    let docRefValue = unref(docOrCollectionRef);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!docRefValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (!docRefValue.converter) {\n        docRefValue = docRefValue.withConverter(\n          // @ts-expect-error: seems like a ts error\n          options.converter\n        );\n      }\n      unbind = (isDocumentRef(docRefValue) ? bindDocument : bindCollection)(\n        // @ts-expect-error: cannot type with the ternary\n        data,\n        docRefValue,\n        ops,\n        resolve,\n        reject,\n        options\n      );\n    }).catch((reason) => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      return Promise.reject(reason);\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(docOrCollectionRef)) {\n    stopWatcher = watch(docOrCollectionRef, bindFirestoreRef);\n  }\n  bindFirestoreRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(\n      promise.value,\n      initialSourceValue,\n      options.ssrKey\n    );\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    error: { get: () => error },\n    data: { get: () => data },\n    pending: { get: () => pending },\n    promise: { get: () => promise },\n    stop: { get: () => stop }\n  });\n}\nconst ops = {\n  set: (target, key, value) => walkSet(target, key, value),\n  add: (array, index, data) => array.splice(index, 0, data),\n  remove: (array, index) => array.splice(index, 1)\n};\n\nfunction useCollection(collectionRef, options) {\n  return _useFirestoreRef(collectionRef, {\n    target: ref([]),\n    ...options\n  });\n}\nfunction useDocument(documentRef, options) {\n  return _useFirestoreRef(documentRef, options);\n}\nfunction useFirestore(name) {\n  return getFirestore(useFirebaseApp(name));\n}\n\nconst databaseUnbinds = /* @__PURE__ */ new WeakMap();\nfunction internalUnbind$1(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\n\nconst databasePluginDefaults = {\n  bindName: \"$databaseBind\",\n  unbindName: \"$databaseUnbind\"\n};\nfunction databasePlugin(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, databasePluginDefaults, pluginOptions);\n  const { bindName, unbindName } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function databaseUnbind(key, reset) {\n    internalUnbind$1(key, databaseUnbinds.get(this), reset);\n    delete this.$firebaseRefs[key];\n  };\n  GlobalTarget[bindName] = function databaseBind(key, source, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!databaseUnbinds.has(this)) {\n      databaseUnbinds.set(this, {});\n    }\n    const unbinds = databaseUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    if (pluginOptions) {\n      if (!pluginOptions.bindName) {\n        GlobalTarget[\"$rtdbBind\"] = GlobalTarget[bindName];\n      }\n      if (!pluginOptions.unbindName) {\n        GlobalTarget[\"$rtdbUnbind\"] = GlobalTarget[unbindName];\n      }\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(\n      () => effectScope()\n    );\n    const { promise, stop: _unbind } = scope.run(\n      () => _useDatabaseRef(source, { target, ...options })\n    );\n    const unbind = (reset) => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firebaseRefs[key] = source.ref;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firebaseRefs = /* @__PURE__ */ Object.create(null);\n    },\n    created() {\n      let bindings = this.$options.firebase;\n      if (typeof bindings === \"function\") {\n        bindings = bindings.call(this);\n      }\n      if (!bindings)\n        return;\n      for (const key in bindings) {\n        this[bindName](\n          // ts\n          key,\n          bindings[key],\n          globalOptions\n        );\n      }\n    },\n    beforeUnmount() {\n      const unbinds = databaseUnbinds.get(this);\n      if (unbinds) {\n        for (const key in unbinds) {\n          unbinds[key]();\n        }\n      }\n      this.$firebaseRefs = null;\n    }\n  });\n}\nfunction VueFireDatabaseOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return databasePlugin(app, pluginOptions, firebaseApp);\n  };\n}\n\nconst firestoreUnbinds = /* @__PURE__ */ new WeakMap();\nfunction internalUnbind(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\n\nconst firestorePluginDefaults = {\n  bindName: \"$firestoreBind\",\n  unbindName: \"$firestoreUnbind\"\n};\nconst firestorePlugin = function firestorePlugin2(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign(\n    {},\n    firestorePluginDefaults,\n    pluginOptions\n  );\n  const { bindName, unbindName } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function firestoreUnbind(key, reset) {\n    internalUnbind(key, firestoreUnbinds.get(this), reset);\n    delete this.$firestoreRefs[key];\n  };\n  GlobalTarget[bindName] = function firestoreBind(key, docOrCollectionRef, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!firestoreUnbinds.has(this)) {\n      firestoreUnbinds.set(this, {});\n    }\n    const unbinds = firestoreUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(\n      () => effectScope()\n    );\n    const { promise, stop: _unbind } = scope.run(\n      () => _useFirestoreRef(docOrCollectionRef, {\n        target,\n        ...options\n      })\n    );\n    const unbind = (reset) => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firestoreRefs[key] = // ts\n    docOrCollectionRef;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firestoreRefs = /* @__PURE__ */ Object.create(null);\n    },\n    created() {\n      const { firestore } = this.$options;\n      const refs = typeof firestore === \"function\" ? firestore.call(this) : firestore;\n      if (!refs)\n        return;\n      for (const key in refs) {\n        this[bindName](\n          key,\n          // @ts-expect-error: FIXME: there is probably a wrong type in global properties\n          refs[key],\n          globalOptions\n        );\n      }\n    },\n    beforeUnmount() {\n      const unbinds = firestoreUnbinds.get(this);\n      if (unbinds) {\n        for (const subKey in unbinds) {\n          unbinds[subKey]();\n        }\n      }\n      this.$firestoreRefs = null;\n    }\n  });\n};\nfunction VueFireFirestoreOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return firestorePlugin(app, pluginOptions, firebaseApp);\n  };\n}\n\nfunction VueFireAuth(initialUser) {\n  return (firebaseApp, app) => {\n    const user = getGlobalScope(firebaseApp, app).run(\n      () => ref(initialUser)\n    );\n    authUserMap.set(firebaseApp, user);\n    setupOnAuthStateChanged(user, firebaseApp);\n  };\n}\nfunction useFirebaseAuth(name) {\n  return isClient ? getAuth(useFirebaseApp(name)) : null;\n}\n\nfunction useFirebaseStorage(name) {\n  return getStorage(useFirebaseApp(name));\n}\nfunction useStorageFileUrl(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const url = ref();\n  url.value = getInitialValue(\n    initialSourceValue,\n    void 0,\n    url.value,\n    useFirebaseApp()\n  );\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getDownloadURL(storageSource).then((downloadUrl) => url.value = downloadUrl).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(url.value = null);\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return { url, refresh, promise };\n}\nfunction useStorageFileMetadata(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const metadata = shallowRef();\n  if (initialSourceValue) {\n    metadata.value = getInitialValue(\n      initialSourceValue,\n      // 'm ' is a prefix to differentiate from urls since both are stored in the same object\n      \"m \" + initialSourceValue.toString(),\n      metadata.value,\n      useFirebaseApp()\n    );\n  }\n  const promise = shallowRef(\n    Promise.resolve(null)\n  );\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getMetadata(storageSource).then((data) => metadata.value = data).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(metadata.value = null);\n    }\n    return promise.value;\n  }\n  function update(newMetadata) {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = updateMetadata(storageSource, newMetadata).then(\n        (newData) => {\n          return metadata.value = newData;\n        }\n      );\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[VueFire]: \"update()\" called with no storage source.');\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return { metadata, update, refresh, promise };\n}\nfunction useStorageFile(storageRef) {\n  const { url, refresh: refreshUrl } = useStorageFileUrl(storageRef);\n  const {\n    metadata,\n    update: updateMetadata2,\n    refresh: refreshMetadata\n  } = useStorageFileMetadata(storageRef);\n  const uploadTask = shallowRef();\n  const snapshot = shallowRef();\n  const uploadError = shallowRef();\n  const uploadProgress = computed(() => {\n    const snap = unref(snapshot);\n    return snap ? snap.bytesTransferred / snap.totalBytes : null;\n  });\n  let unsub = noop;\n  function upload(newData, newMetadata) {\n    const storageSource = unref(storageRef);\n    const currentTask = unref(uploadTask);\n    if (currentTask) {\n      currentTask.cancel();\n    }\n    uploadError.value = null;\n    snapshot.value = null;\n    uploadTask.value = null;\n    url.value = null;\n    metadata.value = null;\n    unsub();\n    if (storageSource) {\n      const newTask = uploadBytesResumable(storageSource, newData, newMetadata);\n      uploadTask.value = newTask;\n      snapshot.value = newTask.snapshot;\n      unsub = newTask.on(\"state_changed\", (newSnapshot) => {\n        snapshot.value = newSnapshot;\n      });\n      return newTask.then((finalSnapshot) => {\n        metadata.value = finalSnapshot.metadata;\n        refreshUrl();\n      }).catch((err) => {\n        uploadError.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        unsub();\n        uploadTask.value = null;\n      });\n    }\n  }\n  function refresh() {\n    return Promise.all([refreshUrl(), refreshMetadata()]);\n  }\n  if (isRef(storageRef)) {\n    watch(storageRef, (storageSource) => {\n      if (!storageSource) {\n        if (uploadTask.value) {\n          unsub();\n          uploadTask.value.cancel();\n        }\n        uploadTask.value = null;\n        snapshot.value = null;\n      }\n      refresh();\n    });\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(unsub);\n  }\n  return {\n    url,\n    metadata,\n    snapshot,\n    uploadTask,\n    uploadError,\n    uploadProgress,\n    upload,\n    updateMetadata: updateMetadata2,\n    refresh\n    // promise,\n  };\n}\nconst useStorage = useFirebaseStorage;\nconst useStorageUrl = useStorageFileUrl;\nconst useStorageMetadata = useStorageFileMetadata;\nconst useStorageObject = useStorageFile;\n\nfunction VueFire(app, { firebaseApp, modules = [] }) {\n  app.provide(_FirebaseAppInjectionKey, firebaseApp);\n  for (const firebaseModule of modules) {\n    firebaseModule(firebaseApp, app);\n  }\n}\n\nexport { VueFire, VueFireAuth, VueFireDatabaseOptionsAPI, VueFireFirestoreOptionsAPI, databasePlugin, firestoreDefaultConverter, firestorePlugin, DEFAULT_OPTIONS$1 as globalDatabaseOptions, DEFAULT_OPTIONS as globalFirestoreOptions, databasePlugin as rtdbPlugin, useCollection, useDatabase, useDatabaseList, useDatabaseObject, useDocument, useFirebaseApp, useFirebaseAuth, useFirebaseStorage, useFirestore, useList, useObject, usePendingPromises, useSSRInitialState, useStorage, useStorageFile, useStorageFileMetadata, useStorageFileUrl, useStorageMetadata, useStorageObject, useStorageUrl };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}